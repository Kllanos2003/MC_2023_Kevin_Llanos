# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_oK9rJwfKmkGZPMIe-Cbt10mC33hnjnV
"""

import math

tolerance = 0.5 * 10**-8
error = 100
n = 1
approximation = 1
iteration = 0
x = 0.85

while error > tolerance:
    old_approximation = approximation
    if iteration % 2 == 0:
        n += 1
        factorial = math.factorial(n)
        approximation += (x ** n) / factorial
    else:
        n += 1
        factorial = math.factorial(n)
        approximation -= (x ** n) / factorial
    iteration += 1
    error = abs((approximation - old_approximation) / approximation) * 100

print("------------")
print("e^-0.85 is approximately: ", round(1/approximation, 8))
print("The approximate error is: ", error, "%")
print("It took ", iteration, " iterations")

import math
import decimal

def euler_taylor(x, es):
    ea = 100
    n = 0
    e = 1
    iter_count = 0  # Counter for the number of iterations
    while ea > es:
        e_ant = e
        n += 1
        term = x ** n / math.factorial(n)
        if n % 2 == 0:
            e += term
        else:
            e -= term
        ea = abs((e - e_ant) / e) * 100
        iter_count += 1  # Increment the iteration counter
    return e, iter_count

# Set the precision of the decimal module to 30 digits
decimal.getcontext().prec = 30

# Calculate e^(-0.85) using the Taylor series with an error tolerance of 0.5e-8
x = -0.85
es = 0.5e-8
result, iterations = euler_taylor(x, es)

# Print the result and the number of iterations
print(f"e^(-0.85) is approximately equal to {result} after {iterations} iterations.")